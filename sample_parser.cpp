

#include "flatbuffers/flatbuffers.h"
#include "monster_generated.h"
#include <iostream> // C++ header file for printing
#include <fstream> // C++ header file for file access

using MyGame::Sample::MonsterT;
using MyGame::Sample::Monster;
using MyGame::Sample::GetMonster;
using flatbuffers::FlatBufferBuilder;

int main() {
    std::ifstream infile;
    infile.open("data/monsterdata.bin", std::ios::binary | std::ios::in);
    infile.seekg(0,std::ios::end);
    int length = infile.tellg();
    infile.seekg(0,std::ios::beg);
    char *data = new char[length];
    infile.read(data, length);
    infile.close();
    auto monster = GetMonster(data);

    std::cout << "hp : " << monster->hp() << std::endl;            // `80`
    std::cout << "mana : " << monster->mana() << std::endl;        // default value of `150`
    std::cout << "name : " << monster->name()->c_str() << std::endl;        // "MyMonster"

    // added by cxt
    const MyGame::Sample::Vec3* pos= monster->pos();
    std::cout << "pos(x,y,z): (" << pos->x() << ", " << pos->y() << ", " << pos->z() << ")" << std::endl;
    const flatbuffers::Vector<uint8_t>* inventory = monster->inventory();
    if (inventory != nullptr) {
        std::cout << "inventory.size: " << inventory->size() << ": ";
        for (int i=0; i< inventory->size(); i++) {
            std::cout << inventory->Get(i) << ", ";
        }
        std::cout << std::endl;
    }
    else {
        std::cout << "inventory is empty!\n";
    }
    
    MyGame::Sample::Color color = monster->color();
    std::cout << "color: " << color << std::endl;

    const flatbuffers::Vector<flatbuffers::Offset<MyGame::Sample::Weapon>>* weapon = monster->weapons();
    std::cout << "weapons.size: " << weapon->size() << std::endl;
    for (int i=0; i<weapon->size(); i++) {
        auto item = weapon->Get(i);
        std::cout << item->name()->c_str() << ": " << item->damage() << std::endl;
    }

    const flatbuffers::Vector<const MyGame::Sample::Vec3*>* path = monster->path();
    if (path != nullptr) {
        std::cout << "path.size: " << path->size() << std::endl;
        for (int i=0; i<path->size(); i++) {
            const MyGame::Sample::Vec3* item = path->Get(i);
            std::cout << "pos(x,y,z): (" << pos->x() << ", " << pos->y() << ", " << pos->z() << ")" << std::endl;
        }
    }
    else {
        std::cout << "path is empty!\n";
    }

    // Autogenerated class from table Monster.
    MonsterT monsterobj;
    // Deserialize from buffer into object.
    GetMonster(data)->UnPackTo(&monsterobj);
    // Update object directly like a C++ class instance.
    std::cout << monsterobj.name;  // This is now a std::string!
    monsterobj.name = "Bob";  // Change the name.
    // Serialize into new flatbuffer.
    FlatBufferBuilder fbb;
    fbb.Finish(Monster::Pack(fbb, &monsterobj));

    const MyGame::Sample::Monster* new_monster = GetMonster(fbb.GetBufferPointer());
    std::cout << "new monster name: " << new_monster->name()->c_str() << ", hp: " << new_monster->hp() << std::endl;

    return 0;
}
